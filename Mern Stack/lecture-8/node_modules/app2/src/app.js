/**
 * app.js 单页面解决方案
 * @author senntyou 2016-11-22
 */
(function( window ) {

    /**
     * json-refactor
     */
    (function( window ) {

        /**
         * 模拟函数
         * @param data
         * @returns {*}
         */
        function fakeFunctionWithReturn (data) {
            return data;
        }

        //克隆对象
        function cloneObject() {
            var obj = arguments[0];
            if (typeof obj === 'undefined' || obj === null)
                return {};

            if (typeof obj !== 'object')
                return obj;

            //第二个参数是属性名称列表，就采用该列表进行刷选
            //否则就克隆所有属性
            var attrs = arguments[1], attr;
            var enable_spec_attr = true;
            if (!(attrs instanceof Array)) {
                attrs = obj;
                enable_spec_attr = false;
            }

            var result = {};
            var key;
            for (key in attrs) {
                attr = enable_spec_attr ? attrs[key] : key;
                if (obj.hasOwnProperty(attr)) {
                    if (obj[attr] instanceof Array) {
                        result[attr] = cloneArray(obj[attr]);
                    }
                    else if (typeof obj[attr] === 'object') {
                        result[attr] = cloneObject(obj[attr]);
                    } else {
                        result[attr] = obj[attr];
                    }
                }
            }

            return result;
        }

        //克隆数组
        function cloneArray(array) {
            if (typeof array === 'undefined' || array === null)
                return [];

            if (!(array instanceof Array))
                return [];

            var result = [];

            array.map(function (item, index) {
                typeof item !== 'object' ? (
                    result[index] = item
                ) : (
                    result[index] = cloneObject(item)
                )
            });

            return result;
        }

        /**
         * 转换类型
         * @param value 带转换的值
         * @param format 格式
         * @returns {*}
         */
        function convertDataType(value, format) {
            switch (format) {
                case 'int':
                    return parseInt(value);
                case 'float':
                    return parseFloat(value);
                case 'bool':
                    return !!value;
                case 'string':
                    return value + '';
                default :
                    !!window[format] && typeof window[format] == 'function' ? (value = window[format](value)) : (
                        console.error("" + format + "：没有此内置操作，也无此全局函数")
                    );
                    return value;
            }
        }

        /**
         * 转换点语法的数据
         * @param target
         * @param mapKey
         * @param originalKey
         * @param format
         */
        function convertDataOfDotKey(target, mapKey, originalKey, format) {
            var originKeyArrayByDot = originalKey.split('.'),//用点号分隔originKey(目前最多只\支持四级)
                length = originKeyArrayByDot.length,
                lastKey = originKeyArrayByDot[length - 1],//最后一个键
                hasArrayMark = !!~lastKey.indexOf('[]'),//是否有数组操作标记
                value;
            if (length == 2) {
                hasArrayMark ? (
                    value = target[originKeyArrayByDot[0]] != undefined && target[originKeyArrayByDot[0]]
                ) : (
                    value = target[originKeyArrayByDot[0]] != undefined && target[originKeyArrayByDot[0]][originKeyArrayByDot[1]]
                );
            } else if (length == 3) {
                hasArrayMark ? (
                    value = target[originKeyArrayByDot[0]] != undefined && target[originKeyArrayByDot[0]][originKeyArrayByDot[1]] != undefined &&
                        target[originKeyArrayByDot[0]][originKeyArrayByDot[1]]
                ) : (
                    value = target[originKeyArrayByDot[0]] != undefined && target[originKeyArrayByDot[0]][originKeyArrayByDot[1]] != undefined &&
                        target[originKeyArrayByDot[0]][originKeyArrayByDot[1]][originKeyArrayByDot[2]]
                );

            } else if (length == 4) {
                hasArrayMark ? (
                    value = target[originKeyArrayByDot[0]] != undefined && target[originKeyArrayByDot[0]][originKeyArrayByDot[1]] != undefined &&
                        target[originKeyArrayByDot[0]][originKeyArrayByDot[1]][originKeyArrayByDot[2]] != undefined &&
                        target[originKeyArrayByDot[0]][originKeyArrayByDot[1]][originKeyArrayByDot[2]]
                ) : (
                    value = target[originKeyArrayByDot[0]] != undefined && target[originKeyArrayByDot[0]][originKeyArrayByDot[1]] != undefined &&
                        target[originKeyArrayByDot[0]][originKeyArrayByDot[1]][originKeyArrayByDot[2]] != undefined &&
                        target[originKeyArrayByDot[0]][originKeyArrayByDot[1]][originKeyArrayByDot[2]][originKeyArrayByDot[3]]
                );

            }
            else {
                console.error("点语法的解析最大只支持四级");
                return;
            }

            hasArrayMark ? (
                target[mapKey] = getDataOfArrayMark(value, lastKey)
            ) : (
                typeof value != 'object' ? (
                    target[mapKey] = !format ? value : convertDataType(value, format)
                ) : (
                    Array.isArray(value) ? (
                        target[mapKey] = cloneArray(value)
                    ) : (
                        target[mapKey] = cloneObject(value)
                    )
                )
            );

        }

        /**
         * 转换普通值
         * @param target
         * @param mapKey
         * @param originalKey
         * @param format
         * @param keepOriginKey
         */
        function convertDataOfCommon(target, mapKey, originalKey, format, keepOriginKey) {
            var targetValue = target[originalKey];//目标值
            target[mapKey] = !format ? targetValue : convertDataType(targetValue, format);
            //如果原来的键与现在的键相同，则只是数据转换，不更换键名，不删除
            mapKey != originalKey && !keepOriginKey && delete target[originalKey];
        }

        /**
         * 转换数组操作
         * @param target
         * @param mapKey
         * @param originalKey
         */
        function convertDataOfArrayMark(target, mapKey, originalKey) {
            target[mapKey] = getDataOfArrayMark(target, originalKey);
        }

        /**
         * 获取数组操作的值
         * @param target
         * @param originalKey
         * @returns {*}
         */
        function getDataOfArrayMark(target, originalKey) {
            var originalKeyArray = originalKey.split("|"),
                key = originalKeyArray[0].slice(0, -2),//操作属性
                subKey = originalKeyArray[1],//对每一个数组中都要操作的值
                action = originalKeyArray[2],//操作
                actionExtra = originalKeyArray[3],//actionExtra
                subAction = originalKeyArray[4],//subAction
                hasSubAction = !!subAction,//是否有子操作
                subActionFunction,//subAction对应的函数
                targetValueOfKey = target[key];

            var sumValue = 0,
                averageValue = 0,
                maxValue = 0,
                minValue = 0,
                concatArray = [];
            if (!targetValueOfKey || !Array.isArray(targetValueOfKey)) {
                console.error("配置的键 " + key + " 不存在，或者值不是数组");
                return;
            }

            if (hasSubAction) {
                switch (subAction) {
                    case "round":
                        subActionFunction = Math.round;
                        break;
                    case "floor":
                        subActionFunction = Math.floor;
                        break;
                    case "ceil":
                        subActionFunction = Math.ceil;
                        break;
                    case "abs":
                        subActionFunction = Math.abs;
                        break;
                    default:
                        subActionFunction = fakeFunctionWithReturn;
                        action != "concat" && console.error("子操作 " + subAction + " 不存在");
                        break
                }
            }

            switch (action) {
                //求和
                case "sum":
                    targetValueOfKey.map(function (item) {
                        hasSubAction ? (
                            sumValue += subActionFunction(item[subKey])
                        ) : (
                            sumValue += item[subKey]
                        );

                    });
                    return sumValue;
                //求平均
                case "average":
                    targetValueOfKey.map(function (item) {
                        hasSubAction ? (
                            sumValue += subActionFunction(item[subKey])
                        ) : (
                            sumValue += item[subKey]
                        );

                    });
                    averageValue = sumValue / targetValueOfKey.length;
                    return averageValue;
                //求最大值
                case "max":
                    targetValueOfKey.map(function (item, index) {
                        var value = hasSubAction ? subActionFunction(item[subKey]) : item[subKey];
                        !index ? (
                            maxValue = value
                        ) : (
                            value > maxValue && (maxValue = value)
                        );
                    });
                    return maxValue;
                //求最小值
                case "min":
                    targetValueOfKey.map(function (item, index) {
                        var value = hasSubAction ? subActionFunction(item[subKey]) : item[subKey];
                        !index ? (
                            minValue = value
                        ) : (
                            value < minValue && (minValue = value)
                        );
                    });
                    return minValue;
                //求字符串链接
                case "concat":
                    targetValueOfKey.map(function (item) {
                        var value = hasSubAction ? item[subKey][subAction]() : item[subKey];
                        concatArray.push(value);
                    });
                    return concatArray.join(!actionExtra ? "" : actionExtra);
                default:
                    console.error("操作 " + action + " 不存在");
                    return;
            }

        }

        /**
         * 转换值
         * @param target 目标对象
         * @param map map
         * @param mapKey map中的key
         */
        function convertValue(target, map, mapKey) {
            //字符串
            var originMapValue = map[mapKey],//map值
                keepOriginKey = !!~originMapValue.indexOf('^'),//是否保留原来的键名
                mapValue = keepOriginKey ? originMapValue.slice(0, -1) : originMapValue,//map值
                mapValueArray = mapValue.split('!'),//map value: "key!format", 感叹号前面是键值，感叹号后面是转换值
                originalKey = mapValueArray[0],//原始键
                format = mapValueArray[1];//格式

            var hasDot = !!~originalKey.indexOf('.'),//里面是否有点号
                hasArrayMark = !hasDot && !!~originalKey.indexOf('[]');//是否有数组标示

            //有点操作符
            hasDot ? (
                originalKey.split('.').length > 1 ? (
                    convertDataOfDotKey(target, mapKey, originalKey, format)
                ) : (
                    console.error("配置键名 " + mapValue + " 有误")
                )

            ) : (
                //数组操作
                hasArrayMark ? (
                    convertDataOfArrayMark(target, mapKey, originalKey)
                ) : (
                    //普通操作
                    convertDataOfCommon(target, mapKey, originalKey, format, keepOriginKey)
                )
            );


        }

        //格式化json
        function format(target, map) {
            if (!map || typeof map != 'object') return;

            //是数组
            Array.isArray(map) ? (
                target.map(function (item) {
                    //如果是对象或数组
                    !!map[0] && typeof map[0] == 'object' && typeof item == 'object' && format(item, map[0]);
                })
            ) : (
                //是对象
                Object.keys(map).map(function (mapKey) {
                    var mapValue,//map值
                        targetValue;//目标值

                    mapValue = map[mapKey];
                    //如果是以下划线开头，并且在原数据中不存在这个键，则就是某个字段的二次改变
                    /**
                     * 修复微信浏览器不支持函数 startsWith, 用slice函数代替
                     */
                    if (mapKey.slice(0, 1) == '_' && typeof target[mapKey] == 'undefined') {
                        targetValue = target[mapKey.slice(1)];
                    } else {
                        targetValue = target[mapKey];
                    }
                    //是对象或数组并且原数据中存在这个字段
                    if (typeof mapValue == 'object' && !!targetValue) {
                        Array.isArray(mapValue) ? (//array
                            targetValue.map(function (item) {
                                //如果是对象或数组
                                if (!!mapValue[0] && typeof mapValue[0] == 'object' && typeof item == 'object') format(item, mapValue[0]);
                            })
                        ) : (//object
                            format(targetValue, mapValue)
                        );
                    } else if (typeof mapValue == 'string') {
                        //字符串
                        convertValue(target, map, mapKey);
                    }
                    else {
                        console.error('无法解析key: \n' + (typeof mapValue == 'string' ? mapValue : (typeof mapValue == 'object' ? JSON.stringify(mapValue) : '')));
                    }
                })
            );
        }

        /**
         * 初始函数
         * @param source 原对象
         * @param map 键值地图
         * @param returnNewJson 是否返回新的json文件（默认：false）
         */
        var jsonRefactor = function (source, map, returnNewJson) {
            var target = !!returnNewJson ? (
                source instanceof Array ? cloneArray(source) : cloneObject(source)
            ) : source;

            !!map && typeof map == 'object' ? format(target, map) : console.error("传入的map格式有误，请传入对象或数组");
            return target;
        };
        window.JSON.refactor = jsonRefactor;

    })( window );

    /**
     * 绑定事件
     * @param eventString 事件字符串
     * @param callback 回调函数
     */
    function bindEvent(eventString, callback) {
        /**
         * 修复微信浏览器不支持函数 startsWith, 用slice函数代替
         */
        var noDelegate = eventString.slice(0, 1) == '!',
            eventStr = noDelegate ? eventString.slice(1) : eventString,
            eventStringArray = eventStr.split(/\s+/g),
            eventName = eventStringArray[0],
            elements;
        if (eventStringArray.length <= 1) {
            console.error("无法解析事件 " + eventString);
            return;
        }
        //把事件名移除
        eventStringArray.shift();
        elements = eventStringArray.join(' ');

        //window和document直接处理
        elements == "window" || elements == "document" ? (
            elements == "window" ? (
                $(window).on(eventName, function (e) {
                    callback.call(config.event, e);
                })
            ) : (
                $(document).on(eventName, function (e) {
                    callback.call(config.event, e);
                })
            )
        ) : (
            //不使用代理
            noDelegate ? (
                $(elements).on(eventName, function (e) {
                    callback.call(config.event, e);
                })
            ) : (
                //有代理元素
                !!config.event.el ? (
                    $(config.event.el).on(eventName, elements, function (e) {
                        callback.call(config.event, e);
                    })
                ) : (
                    //否则使用document
                    $(document).on(eventName, elements, function (e) {
                        callback.call(config.event, e);
                    })
                )
            )
        );
    }

    /**
     * 处理事件监听
     * @param config
     */
    function eventHandle(config) {
        var event = config.event,//整个事件对象
            events = event.events;//事件集合
        Object.keys(event.events).map(function (key) {
            //绑定
            !!event[events[key]] ? bindEvent(key, event[events[key]]) : (console.error("方法 " + events[key] + " 不存在"));
        });
    }

    /**
     * 编译模板（支持二级）
     * @param config
     */
    function compileTemplate(config) {
        var compiledTemplate = {},
            templateRenderer;

        if (!!config.templateRenderer && typeof config.templateRenderer == 'function') {
            templateRenderer = config.templateRenderer;
        }
        else if (typeof juicer == 'function') {
            templateRenderer = juicer;
        }
        else {
            console.error('config.templateRenderer 没有配置，也没有加载juicer，故不能编译模板');
            return;
        }

        Object.keys(config.template).map(function (key) {
            typeof config.template[key] == 'object' ? (
                compiledTemplate[key] = {},
                    //二级
                    Object.keys(config.template[key]).map(function (subKey) {

                        typeof config.template[key][subKey] == 'object' ? (
                            //三级
                            compiledTemplate[key][subKey] = {},
                                Object.keys(config.template[key][subKey]).map(function (subSubKey) {
                                    compiledTemplate[key][subKey][subSubKey] = templateRenderer(config.template[key][subKey][subSubKey])
                                })
                        )
                            :
                            (
                                compiledTemplate[key][subKey] = templateRenderer(config.template[key][subKey])
                            )

                    })
            ) : (
                compiledTemplate[key] = templateRenderer(config.template[key])
            );
        });
        config.compiledTemplate = compiledTemplate;
    }

    /**
     * 渲染模板项目
     * @param $el
     * @param tplName
     * @param item
     * @param append
     */
    function renderTemplateItem($el, tplName, item, append) {
        var compiledTemplates = config.compiledTemplate,
            action = !!append ? "append" : "html",//使用append方法还是html方法
            hasDot = !!~tplName.indexOf('.'),//是否有点语法
            tplNameArray = hasDot && tplName.split('.'),
            compiledTpl;

        //一级
        if (!hasDot)
            compiledTpl = compiledTemplates[tplName];
        else if (tplNameArray.length == 2)
            compiledTpl = !!compiledTemplates[tplNameArray[0]] && compiledTemplates[tplNameArray[0]][tplNameArray[1]];
        else if (tplNameArray.length == 3)
            compiledTpl = !!compiledTemplates[tplNameArray[0]] && !!compiledTemplates[tplNameArray[0]][tplNameArray[1]] &&
                compiledTemplates[tplNameArray[0]][tplNameArray[1]][tplNameArray[2]];
        else {
            console.error('模板最大只支持3级');
            return;
        }
        !!compiledTpl ? $el[action](compiledTpl.render(item)) : console.error("模板 " + tplName + " 不存在");
    }


    var config = {},//配置
        request = {},//请求
        elementData = {};//元素数据


    /**
     * 格式化请求数据
     * @param url int/string
     * @param data []/{}
     * @returns {*[]}
     */
    request.getFormatData = function (url, data) {
        var name = config.ajax.name[url],
            index = config.environment,
            newData = {};
        index == undefined && (
            console.error("环境变量 config.environment 没有配置, 默认取值为0的环境"),
            index = 0
        );
        !name && (
            console.error("config.ajax.url中无 " + url + " 对应的值")
        );
        Array.isArray(data) ? (
            data.map(function (item, idx) {
                newData[config.ajax.requestKeys[name][index][idx]] = item
            })
        ) : (
            Object.keys(data).map(function (item) {
                newData[config.ajax.requestKeys[name][index][item]] = data[item]
            })
        );
        return [
            config.ajax.url[name][index],
            newData
        ];
    };

    /**
     * 预处理请求数据
     * @param data json: 请求数据
     * @param url int/string
     */
    request.preHandle = function (data, url) {
        var name = config.ajax.name[url],
            index = config.environment,
            commonHandle = !!config.ajax.preHandle && !!config.ajax.preHandle.common && config.ajax.preHandle.common,
            nameHandle = !!config.ajax.preHandle && !!config.ajax.preHandle[name] && config.ajax.preHandle[name];
        !!commonHandle && (
            typeof commonHandle == 'function' ? (
                //是函数
                !index && commonHandle(data)
            ) : (
                //数组
                !!commonHandle[index] && commonHandle[index](data)
            )
        );
        !!nameHandle && (
            typeof nameHandle == 'function' ? (
                //是函数
                !index && nameHandle(data)
            ) : (
                //数组
                !!nameHandle[index] && nameHandle[index](data)
            )
        );
    };

    /**
     * 后置处理返回的数据
     * @param res json: 请求数据
     * @param url int/string
     */
    request.postHandle = function (res, url) {
        var name = config.ajax.name[url],
            index = config.environment,
            commonHandle = !!config.ajax.postHandle && !!config.ajax.postHandle.common && config.ajax.postHandle.common,
            nameHandle = !!config.ajax.postHandle && !!config.ajax.postHandle[name] && config.ajax.postHandle[name],
            commonRefactor = !!config.ajax.responseRefactor && !!config.ajax.responseRefactor.common && config.ajax.responseRefactor.common,
            nameRefactor = !!config.ajax.responseRefactor && !!config.ajax.responseRefactor[name] && config.ajax.responseRefactor[name];
        !!commonRefactor && (
            !Array.isArray(commonRefactor) ? (
                //是对象
                !index && JSON.refactor(res, commonRefactor)
            ) : (
                //数组
                !!commonRefactor[index] && JSON.refactor(res, commonRefactor[index])
            )
        );
        !!nameRefactor && (
            !Array.isArray(nameRefactor) ? (
                //是对象
                !index && JSON.refactor(res, nameRefactor)
            ) : (
                //数组
                !!nameRefactor[index] && JSON.refactor(res, nameRefactor[index])
            )
        );
        !!commonHandle && (
            typeof commonHandle == 'function' ? (
                //是函数
                !index && commonHandle(res)
            ) : (
                //数组
                !!commonHandle[index] && commonHandle[index](res)
            )
        );
        !!nameHandle && (
            typeof nameHandle == 'function' ? (
                //是函数
                !index && nameHandle(res)
            ) : (
                //数组
                !!nameHandle[index] && nameHandle[index](res)
            )
        );
    };
    /**
     * 发起请求
     * @param method 请求方法
     * @param url 请求地址
     * @param data 请求json数据
     * @param callback 请求回调
     * @param type 请求返回数据类型
     * @param stringify  是否序列化请求参数
     */
    request.send = function (method, url, data, callback, type, stringify) {
        var formatData = request.getFormatData(url, data);
        !type && (type = 'json');
        //前置处理
        request.preHandle(formatData[1], url);
        //请求
        $[method](formatData[0], !stringify ? formatData[1] : JSON.stringify(formatData[1]), function (res) {
            //后置处理
            request.postHandle(res, url);
            callback(res);
        }, type)
    };
    /**
     * 发起get请求
     * @param url
     * @param data
     * @param callback
     * @param type
     */
    request.get = function (url, data, callback, type) {
        request.send("get", url, data, callback, type, !1);
    };
    /**
     * 发起post请求
     * @param url
     * @param data
     * @param callback
     * @param type
     * @param stringify
     */
    request.post = function (url, data, callback, type, stringify) {
        arguments.length == 4 && typeof type == 'boolean' && (
            stringify = type,
                type = 'json'
        );
            request.send("post", url, data, callback, type, stringify);
    };

    /**
     * 存放数据
     * @type {{}}
     */
    elementData.data = {};
    /**
     * 绑定名称、对象
     * @param config
     */
    elementData.bind = function (config) {
        Object.keys(config.dataBind).map(function (key) {
            //初始化每一个数据
            elementData.data[key] = {};
        });
    };
    /**
     * 设置数据(私有方法)
     * @param name
     * @param data
     * @param append
     */
    elementData._setData = function (name, data, append) {
        if (!config.dataBind[name]) {
            console.error("配置的数据绑定键名 " + name + " 不存在");
            return;
        }
        //append 默认为false
        append == undefined && (append = !1);
        var dataBindCell = config.dataBind[name],
            tplName = dataBindCell.template,
            realTplName,//真实模板名
            fieldName,//多个模板选择对应的字段名
            $el = $(dataBindCell.element),
            firstToOverride = !append,//是否是去覆盖数据
            multiTemplates = !1;//多模板
        if (!tplName) {
            console.error("键名 " + name + " 对应的模板名不能为空");
            return;
        }
        //tplName是对象，说明是多个选择性模板
        typeof tplName == 'object' && (
            multiTemplates = true,
                fieldName = Object.keys(tplName)[0]
        );
        append ? (
            //追加数据
            Array.isArray(data) ? (
                //如果是数组，则逐个追加
                data.map(function (item) {
                    realTplName = multiTemplates ? tplName[fieldName][item[fieldName]] : tplName,
                        renderTemplateItem($el, realTplName, item, true)
                })
            ) : (
                realTplName = multiTemplates ? tplName[fieldName][data[fieldName]] : tplName,
                    renderTemplateItem($el, realTplName, data, true)
            )
        ) : (
            //设置数据
            Array.isArray(data) ? (
                //如果是数组，则逐个添加
                data.map(function (item) {
                    realTplName = multiTemplates ? tplName[fieldName][item[fieldName]] : tplName,
                        //如果是数组，第一个覆盖，后面的元素会采取追加
                        firstToOverride ? (
                            renderTemplateItem($el, realTplName, item),
                                firstToOverride = !1
                        ) : (
                            renderTemplateItem($el, realTplName, item, true)
                        )
                })
            ) : (
                realTplName = multiTemplates ? tplName[fieldName][data[fieldName]] : tplName,
                    renderTemplateItem($el, realTplName, data)
            )
        );

    };
    /**
     * 设置数据
     * @param name
     * @param data
     */
    elementData.setData = function (name, data) {
        elementData._setData (name, data, !1);
    };
    /**
     * 追加数据
     * @param name
     * @param data
     */
    elementData.addData = function (name, data) {
        elementData._setData (name, data, true);
    };

    var app = {
        init: function (paramConfig) {
            config = paramConfig;
            //处理事件绑定
            !!config.event && !!config.event.events && eventHandle(config);
            //编译模板
            !!config.template && compileTemplate(config);
            //绑定数据模型
            !!config.dataBind && elementData.bind(config);
            app.get = request.get;
            app.post = request.post;
            app.setData = elementData.setData;
            app.addData = elementData.addData;
            app.compiledTemplate = config.compiledTemplate;
        }
    };
    if ( typeof define === "function" && define.amd ) {
        define(function() { return app; });
    } else if ( typeof module !== "undefined" && module.exports ) {
        module.exports = app;
    } else {
        window.app = app;
    }

})( window );